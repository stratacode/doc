<html extends="ArticlePage">
<head title="Motivation for layers"/>

<body>
   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Motivation for layers

by Jeff Vroom

As a thought experiment, think about where you find the layer design pattern in software you use.  Here's a few I can think of: Java's classPath, "monkey patching", maven overlays, objective C 'mixins'.   

Now let's think about the natural world and consider the places where "layered designs" occur.  You find layers in the structure of just about anything - organic or inorganic.  For a clear example, take a look at the structure of the brain.  Layers are a fundamental way complexity is organized in nature.  So we see layers in both the computational and natural worlds frequently and yet in modern programming languages, the pattern is not unified. Instead, layers appear here and there as ad-hoc features. In nature, layers form an essential organizational abstraction. Programmers today generally follow the one file, one type pattern and use modules to organize groups of types. 

What if we modeled code more as an organic system, that mutates and evolves incrementally. Build plugins, and type-safe and traceable augmentation into a language, then use it for the build and run operations. What if we added layers as the foundational organizing concept instead of modules? 

StrataCode attempts to answer that question by using layers to add a hinge point to our design flexibility for building and maintaining larger, and more complex systems more easily. Use layer oriented programming just like with modules when building new systems. Refactor aspects of code based on role:  domain model, persistence, UI for a more manageable design and reusable code. 

For large existing code bases, use layers to refactor code in-place. Insert layers to separate aspects of your system - old versus new, to migrate large code bases that are in flux with the ability to build the old and new systems from the same code base during the transition.

Layers provide plugins built into the language so architects can focus on expressing the domain model in the simplest possible way. Layers support merge, and split operations so that code bases can more naturally evolve throughout it's lifecycle, and be more customizable to improve user satisfaction.

## More flexible than modules

Like modules, layers package code and manage dependencies for assembling a program.  A layer extends one or more other layers to ensure they are compatible and included along with the layer. Layers can do everything modules do but more. They support overriding of files, modifying types, and changing the build and code-processing environment with more flexibility. 

## Still statically typed

Layers retain the benefits of encapsulation and are statically typed, adhering to the <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID principles</a> of O/O design.  They may replace or add to an object's interface or override but cannot (or it's a bad practice) to remove a previously defined contract.  They cannot depend on a layer that comes after them in the current list of layers which preserves the maintainability of large systems. 

At the code level, like Java, code paths are traceable so the edit time errors catch most errors and navigation and changes are faster with find usages, refactoring and more. Layers are not really new and have been implemented in similar forms before: <a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&cad=rja&ved=0CDYQFjAB&url=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D1885647&ei=vLBRUsaBNaGqiAK7moCICA&usg=AFQjCNGUS5M8Ep_9HKm8GO_terTa9cMT_g&bvm=bv.53537100,d.cGE">Delta oriented programming</a>. Layers also make a great environment for developing product feature-lines.

## Modules and circular references

As systems built with modules grow in size, they tend to develop circular dependencies. For example, Module A depends naturally on Module B but as the project grows, some minor aspect of B may develop a dependency on some minor aspect of A, possibly due to a poor modularization decision.  Refactoring to eliminate the circular dependency would work but breaks compatibility and so may not be an option. The API contract has been "burned in stone" or perhaps just awkward or expensive to change given the number of dependencies. Allowing the new circular dependency creates code management problems long term but is the only way to get the job done now. 

Practically, A and B now must be updated in coordination, losing many of the benefits of modularization.  Changes in B may depend on changes in A and vice versa.  It becomes problematic now to test a new version of A with an old version of B and vice versa.  Each situation seems small at the time, but in large systems this design results in efficient engineering long term. 

Not surprisingly, back in nature we find the organizational structure of DNA as a mostly ordered (you might say layered) list of elements, not a connected cyclic or acyclic graph. 

Once DNA is expressed in cells, a massive web of interdependencies evolves. In my intuitive sense, evolution unfolds in layers, like a protein rolling itself up, requiring a cadence and linear order to keep the complexity organized.

In the programming world, we maintain code using a graph of dependent things - using include and extends as the fundamental operators. There's no univeral 'modify' and no universal ordering to keep things organized.

In nature, new things come along and modify what's there, in essence creating new types that modify types. Types are identifiable with some marker (or a type name). Nature is good at repurposing markers with modified versions and managing those modifications at many levels. 

In StrataCode these markers are a single name-space of types and instances. Layers are ordered using a variety of rules to create a stack with consistent, controllable order using rules to help developers organize code according to role and dependency. Files can be replaced or modified using code-preprocessing. 

## Layers eliminate circular references 

With layers, a downstream layer cannot refer to an upstream layer in the definition file (lots of upstream dependencies form from the stack form right after the stack has been defined). Although code dependencies are really only enforced at compilation time, it's easy to detect when code in a layer on the bottom refers to code in a layer above it from tools. It's best practice to ensure code dependencies only go in one way to preserve modularity as systems grow. 

With layers, to avoid cyclic dependencies, just add the new feature in a new layer that extends both of the previous ones.
It separates minor dependencies from the bulk of the code and allows downstream code to avoid this dependency if they don't need that new feature. The downstream code retains the independence of the rest of the upstream code without breaking APIs or compatibility. If you want existing clients to see this new module, the new layer is named "A" and the old "A" is renamed.  If you want to offer this as an opt-in feature, you give the new layer a new name and tell clients to point to that layer to get that feature.

Languages like OCaml do not allow cyclic references between modules.  It's a hard-line decision that yields faster start up times, more modular systems so in some ways a good language level design decision.  But it comes at a huge cost to "upgradeability".  As your system grows more complex, some changes may require refactoring to avoid a conflicting dependency.  Without the ability to use a cyclic reference, you need to move code from one type to another to avoid a new upstream dependency.  That will inevitably break any code using the code that has to move, causing unnecessary work, headache, and overall friction for the consumers of any upstream systems. 

Layers give you the best of both worlds: the option to enforce one-way dependencies in the modular structure for a given group of modules, and the ability to incrementally add cyclic relationships to types while keeping the code modular.  

Here's a diagram comparing the way dependencies evolve in your code from one version to the next, comparing a typical modular organization to one using layers:
<% ) %>

<img style="margin:0px auto;display:block" src="../images/deps.png" alt="Dependencies between Modules and Layers"/>

<%= MarkDownPage.markDown(%>
Version 1 of both designs is the same.  But in both designs for version 2 we need two new dependencies.   Some minor feature added to module C now depend on some minor feature of types in A and similarly a minor feature in module E now depends on D.  With modules only, these new dependencies take away many of the benefits of modularity leaving essentially one hairball of code.   When using layers, we can make the same changes without creating a hairball by adding these new minor features in a new layer.  This layer modifies types C and E creating new versions of these types which have the feature, but only when that layer is present.  With layers, only code which requires the new features needs to depend on the new layer.   The bulk of the existing code does not have the new dependency.   Tests and older code can continue to use the older independent versions retaining the benefits of the existing module structure.  APIs do not change as code moves from one layer to the next.  To get the same benefit with modules, we'd have to create new classes which breaks the existing APIs.

## Dealing with complex types

It's very difficult to keep two complex types in your system from developing a circular dependency between them - e.g. "User" and "ShoppingCart".  The most intuitive types are built from natural entities in the system and two complex entities may need to depend on each other to implement certain features.  By splitting complex types into a small number of well organized layers, you can support these types of use cases beautifully, and make those large files easier to navigate as well.

## Mechanics of layers

Like modules, layers may extend one or more other layers which they depend upon.  This exposes all of the types and instances in that layer to the extending layer.  Layers also can pass along imports to subsequent layers.  Each layer gets a nice sandbox of all of the types imported by the layers it extends.  Downstream code does not depend on the exact package name of an imported type, allowing you to easily substitute variants by adding an intermediate layer.

For any specific use case, it's easy to create one layer which pulls in all dependent layers.  But it's also convenient to add additional layers to the run configuration, as options, or new ways to run the one application layer.  Either way, all dependent layers are automatically included and sorted.   Ultimately each collection of layers - a layered system - maintains a single ordered list of layers at any given time which are merged to form the "runtime view" of the application.

An unconstrained layer can modify any type, in any package and sometimes this is useful because the layer may ultimately affect any type in the system.  But such 'global layers' are relatively rare.  In most cases you specify a package for the layer.  When you do, you can only modify types in that package in that layer.  Additionally, files in the layer's directory use that package without the extra directories Java typically makes you create to organize code.  This is particularly nice when layers are edited by non-programmers, or when you can infer categorization by context.   Instead of a "one size fits all" project directory structure, framework developers can create simpler project types, customized for different groups of users: e.g. deployment-configuration, application-configuration, source code, localization, user-interface style, etc.

Certain layers are designed as "build layers".  These layers are validated and compiled to produce Java classes or applications which can be run or tested.  When you compile a stack of layers, you might have more than one build layer in the stack.  In that case, the build is done incrementally - so only the changed types from one stack to the next are re-generated and recompiled.  This makes it efficient to define incremental builds - so only the source you are changing gets recompiled from one build to the next.

## Why layers?

Why objects, why methods, etc.  Consider that object-oriented design may have missed a key "hinge point" for code customization.  Layers add the the ability to refine types and refactor code to keep dependencies separate from complex types.   Some languages add "mixin features" in an ad-hoc way that undermines code traceability and design integrity.  Perhaps the lack of layers has helped fuel the growth for dynamically typed languages because O/O frameworks are awkward when applied to certain problems. The addition of dynamic layers allows you to work with dynamically modified types, but still retain the concept of types. 

At the end of the day, it's difficult to describe the need for layers, because clarity of this design principle appears at higher design complexity than most have the need to consider.  You'll realize the benefits when maintaining large, highly customized code bases, often distributed over many developers, like those commonly found in enterprise applications and frameworks.  In those situations, layers provide major benefits by helping to improve workflows for enterprise systems, separating design, administration, business rules, workflow, and code. 

When combined with StrataCode's declarative features, layers provide a hinge point for customizing any property of any object. 
You can replace any element of any HTML file.  Append to or replace any component.  Override any formula.  Though layers add a new concept, the IDE and management UI frameworks make it easy to build powerful, customizable applications.

## Pure domain models   

Among software architects, the term "domain model" usually refers to the core business code.  The goal is to keep this code pure - so it does not depend on the the user-interface, database, etc for maximum reusability.  The domain model specifies the types of objects involved in the business, the properties of those objects, configuration of the objects, operations performed on them, and rules that should be applied or enforced.  Ideally this model is mostly declarative and independent from the database, user-inteface and other framework specific aspects of the system.  The faster you can evolve your domain model, the faster your business evolves towards greater efficiency. 

The design challenge begins when you try to express your domain model in a programming language.  You need a good type system, efficient compiler, etc, and at the runtime level you need flexibility to create "many integrations" with highly varying needs for the timeliness, rate, and integrity requirements for accessing and updating data.  Your code rapidly collects dependencies on both the runtime, and on external systems.  Each dependency limits your ability to reuse that code in other contexts.  You satisfy the conflicting dependencies through code copying, and building remote interfaces - treating this logic as a service coupled loosely to other systems and code bases.  These remote systems frequently need to copy data as well, data de-normalization, for operational needs.  Whatever approach you take, the logic behind the domain model leaks into other systems with more difficult to manage dependencies.  This makes it harder to adapt to changing business needs.

Layering helps you preserve an independent version of your domain model which is expressed in all of the contexts in which it's required.  Dependencies exist in framework specific layers that annotate or modify the domain model in a structured way.  Those dependencies are translated into the generated code.  By keeping them out of the domain model source, you make that source reusable in any future context.  Using annotations, base layers, base classes, etc. you can write powerful framework features to manipulate the code of your domain model so it's properly serialized, stored in a database, de-normalized, and decoupled for operational reasons but without touching the domain model using powerful code-generation, and framework features that operate on the code as data.  For situations where you need to customize domain model code for a framework, you override features in a traceable way that makes it easier and faster to maintain.  When you need to break apart services for operational needs, share the overlapping parts of the domain model between services so you have statically typed system that is easily refactored.

Let's look at a simple domain model object:

<% ) %>

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>class Quiz {
   String name;
   List<Question> questions; 
}
<% ) %>

You can add JPA persistence with a new layer that contains a simple Quiz.sc file that modifies the Quiz object:

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>@Entity
@Table(name="quiz")
Quiz {
   // Primary key is the quiz name
   override @Id name;

   // Define a one to many relationship between a quiz and its
   // questions.  The questions will automatically be persisted when the
   // quiz is persisted.
   override @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER) questions;
}
<% ) %>
You can add annotations to existing properties and methods from a layer that modifies the domain model layer. 
When you modify a property in a layer, you add that property to the list of properties in that layer.   This additional way to create multiple overlapping sets of properties has a variety of uses in improving design of systems.  For one, management UIs can organize different views customized for different audiences.  Or you can set additional layer-level defaults which apply to all properties in a layer - making them all by default persistent, traceable, serializable, etc.
<p>
To use a quiz, you might also create an instance of a Quiz in one layer:
</p>
<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>object ScienceQuiz extends Quiz {
   name = "Science";
}<%) %>
and initialize it in a separate layer:

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(%>ScienceQuiz {

   questions {
      object question1 extends Question {
         question = "The galaxy we live in is called the Milky Way.  It is shaped\n" +
                    "approximately like:";
         answerChoices = { "A round ball", "A doughnut", "A pretzel", "A flat spiral" };
         answerIndex = 3;
         answerDetail = "The Milky Way has four spiral arms radiating out from a\n" +
                        "central cluster of stars (nucleus).  Our solar system is\n" +
                        "located on one of the spiral arms, quite far from the\n" +
                        "center.";
      }
   }
}
<% ) %>

<%= MarkDownPage.markDown(%>
This is a nice example of a configuration layer you could hand-off to someone else.

To make that easy, each layer is stored in a separate directory with parallel file names and path structure which can be swapped in and out of the application for different purposes.  You can map where source files in a layer end up in the build configuration by extending base layers which define the context.

So layers help partition assets among people: business analysts, designers etc.  One person defines the data model, another manages persistence, a third manages business data and rules.  Layers help separate assets along role boundaries for better workflows. 

Just as layers separate code by their dependencies, so do they separate code by the individuals who manage them.  These two are commonly related for essential reasons, so why not use an environment which supports that separation.

## Self-aware, manageable dynamically changing systems

In most large, complex systems a great deal of the complexity occurs in the management user interface - not the external, customer facing interface. The ability to scale the efficiency of a platform is determined on how quickly the platform's management UI scales, as well as how quickly customer's can scale their own management UI.

The best systems provide customizable management UIs. This includes hard to implement feeatures: adding new fields to data models, new rendering templates, customizing business rules, adding 3rd party integrations via webhooks or inserting code snippets, installing new features or 3rd party plugins.

While you can hard-code the management UI, it means a lot of code for each change in the domain model and a lot of work to keep in sync if the management UI has more than one UI. Most systems use runtime reflection and annotations so the management UIs follow the underlying domain model. 

To provide the best management UIs, StrataCode offers not only runtime reflection but also compile time augmentation, using code-processing. Hooks can be injected to track instances that can be removed for production. 

Management UIs are also the most flexible when they can change rules, and small bits of code on the fly. The "dynamic runtime" in StrataCode is a reflective, self-aware library that can be added to a manageable application to provide on-the-fly code updates using dynamic layers. Dynamic layers can later be compiled for efficient production.
 
## Styles and design elements

Style sheets separate configuration from code in a clean way and are very powerful but sometimes overkill and overly complicated.  How do you find and isolate the effects of a code change?  Style sheets do not have the equivalent of a "find usages" at development time.  Fortunately good debuggers help us trace that down at runtime or we'd be lost.   

Sometimes it's better to constrain things and not use the more flexible selector types in CSS.  If you use a simpler model for style management with standard types, layers and multiple inheritance you retain the ability to find all usages and make changes using static typing for more reliability and control.

Layers by themselves provide separation between code and styles.  The code exposes the customizable properties - on both classes and instances through the same name-space.   Designers deal with a single tree of types and properties.  All of this is toolable because of strong typing, and Java's visibility rules.  

<% ) %>

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>UnitConverter {
   foreground = Color.WHITE;
   background = Color.BLACK;
   errorLabel {
     foreground = Color.RED;
   }
}
<% ) %>

<%= MarkDownPage.markDown(%>

StrataCode's multiple inheritance feature lets you apply properties across the class hierarchy as well.  This gives you a strongly typed version of stylesheet's "class" selector.  Object names are analagos to the "id" selector.  

The design phase pratically requires immediate updates so you can experiment with different looks quickly and dynamic layers let you do that without compromising on runtime performance.

## Testing/Monitoring 

It's common to want to instrument your code in various ways to improve it's testability and monitorability.  In some cases, there are hard tradeoffs to make for performance or readability.   Aspect oriented programming for a while was viewed as a viable approach to this problem for inserting code involved in "cross-cutting" concerns: logging, assertions, timing, etc.  While it did reduce the quantity of code you had to write, it did not use traceable or debuggable patterns and so never gained widespread traction. 

Layers let you inject code from separate files so that you can add this code in a way that preserves these code paths.  For example, you could modify the core 'process()' method with a method that does timing around that method, then called super.process().  When you include this layer, you'd have a monitored version of the application and when it was excluded you'd avoid that overhead and any dependencies it created to the monitoring package.  The layer itself would be a directory tree that showed all monitoring hinge points.  If you renamed the "process" method, this layer would be updated automatically... if you deleted it, you'd get an error reminding you that you need to update the monitoring hook.

Here's a simple example of inserting monitoring code before and after some servlet:

<% ) %>

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>MainProductionServlet {
  void service(ServletRequest request, ServletResponse response) {
    SystemMonitor.monitorStart("ProductionServlet");
    boolean success = false;
    try {
       super.service(reuqest, response);
       success = true;
    }
    finally {
       SystemMonitor.monitorEnd("ProductionServlet", success);
    }
  }
}
<% ) %>

<%= MarkDownPage.markDown(%>

Behind the scenes, StrataCode will create a new MainProductionServlet class when this testing layer is included.  It will use that class instead of the default one.  You can create layers which add much more testing and monitoring logic because it is isolated both from the core code and core runtime.

## Localization

Localization is one of the most common and most important forms of application customization.  Layers give you some new tools and benefits as with other forms of customization.   

For programmers, the easiest way to develop code is to hardcode the strings so it's easiest to change them and understand the code.  Localization typically involves putting a resource identifier into the code and moving the string into a separate file.  Some systems let you use one language in the code and then provide a separate file that maps strings in that language to another based on string-name.  

Both of these schemes have problems.  Most of the time, you are debugging the program in one locale so the resource identifier schema adds overhead to something you do a lot - go from error message to source code.  But that's just an annoyance.  You also lose static typing for compile time errors.   Instead you find out about missing resources at runtime... which means you have to run everything in each locale.  Given the number of possible locales and the breadth of your test suite, that inevitably leads to error messages you fail to localize.

programmers define strings with static final/const variables and initialize them as they might normally.  You simply override those strings in sub-layers, one for each locale.  At compile time, a new class is generated which replaces the original strings with the new strings.  You get a new efficient localized executable for a smaller download size.  Or use a dynamic layer and apply it at runtime for a resource bundle approach.

<% ) %>

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>MainAppPanel {
   welcomeMessage="Welcome {0}!";
}
<% ) %>

Localization does not stop at changing strings.  You might also need to adjust UI spacing for a given language, or re-arrange menu items to preserve case-sensitive order.  With StrataCode, one layer can manage all of these aspects by providing one modularization structure that can modify code and configuration  making it easy to manage and build localized systems.

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>MainAppPanel {
   welcomeMessage = "Willkommen {0}!";
   leftSideWidth := windowSize * 0.25;
}
<% ) %>

   </div>

   </div>
</body>

</html>
