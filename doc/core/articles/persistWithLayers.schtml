<html extends="ArticlePage">
<head title="StrataCode - The Language That Changes Everything"/>

<body>
   <div id="content"><div id="mainSection">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Persistence using layers

Managing the persistent storage for an application is another source of code that can slow down application development. Depending on what you need, some light-weight way to embed SQL in your code, or some object/relational mapping technique, or your NoSQL or JSON oriented database using the API of choice are your best options. You can use all of these approaches with StrataCode, and even combine them using layers to keep the database code separate from the application code.

There are JPA layers for generating a default persistence.xml file from annotations. Another nice practice is to break domain models up into layers based on logical groupings of properties, considering what groups of properties belong together from the code and storage perspective. For example, in a User object you might separate out login properties, profile properties, and orderHistory as three separate groups.  This would make it easier to code-generate more flexible domain models in the future.

There are several planned features to leverage layers and code processing for persistence:

* Persistence with synchronization:  the sync system can automatically persist objects on the server using a database or client using an offline store.  Errors and conflicts can be reflected back for the application to resolve using error handlers and conflict resolution policies.

* Use layers to provide a unified application programming model for data which is stored in different persistent stores - SQL, NoSQL, JSON in SQL.  Code generation will generate a combined object which lazily pulls in from each data source, exposing the unified contract, doing joins as necessary directed by annotations or some code hooks.  Since you specify the meta-data per layer, with some more framework level support, we will be able to use this organization to build one configuration which groups all fields in the same database, and another which groups them in separate databases.  This new framework support could detect the id properties in the overlapping model and generate the code necessary to seamlessly implement a split database organization with "on demand" join.  

* Use layers to store changes to a record or set of records.  A layer will store a set of changes made to an external data store, and present a view of the complete data store with the changes merged, while keeping modifications made separate. Stage data changes for a content database, then merge them in once testing is complete. Turn layer of data on or off to control who sees these changes. Run tests against the production DB but making changes in a temporary layer to keep tests from harming production without limiting the code paths used by the tests.

* Use code-generation to make "plain java objects" work in a transactional way.  They will use a shared cache for read-only operations.  On the first change in a transaction for a given instance, we'll create a separate property store for the changes for that transaction.  If we can't synchronize access to the instance, we can use a thread-local lookup in the getX method to find the store for that thread.  Either way, the getX method will consult this store before using the global cache so only the transaction will see the change until it's committed.  We'll support various ways of synchronizing the global cache with a backend store.  This architecture will perform much faster than using hibernate or any other JPA implementation in a cached environment with a large graph of objects.  It also maps nicely onto the scope system, so we'll have an efficient option to use these objects in scopes to serve as a cache of shared data.

<% ) %>
   </div>

   </div></div>
</body>

</html>

