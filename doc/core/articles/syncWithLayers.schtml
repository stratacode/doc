<html extends="ArticlePage">
<head title="Synchronization with Layers"/>

<body>
   <div id="content"><div id="mainSection">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Synchronization with layers

by Jeffrey Vroom

One of the larger complicating factors in software design, performance, and maintenance begins when two programs need to communicate.  The developer needs to design or choose a protocol, perhaps adds versioning so it can be easily upgraded or changed.  They need to make it secure, reliable and possibly deal with retries in case of failure or handle the additional connection related errors that might occur.  

In my experience, quite a bit of code goes into solving this problem.  It's one of the large contributors to "code that's not application logic" that developers spend time on - writing or debugging. 

## Client/server programming today

Today client/server programmers commonly use remote procedure calls (RPC) with a serialization protocol like JSON to communicate with the server.  Sometimes programmers write "wrapper code" to convert objects to and from JSON, giving them the most control but adding more code to maintain or update when things change. 

More automated frameworks will generate the serialization code or metadata using annotations on methods and their parameters or use a declarative file to define the protocol which generates code for both client and server. This approach reduces the amount of code developers have to write and provides more features with the downside of adding problems during debugging. It's complex to manage all of the uses of 'rpc' that an application might need for a complex domain model that is evolving quickly with lots of read/write APIs required. Not super fun to debug generated code that comes from some XML file but it's better than nothing. 

Another approach is to add a new language for the client/server protocol like GraphQL. It is a much more powerful than basic RPC and has had some success with developers because it improves performance and reduces the number of RPC methods needed. It's another complete language to learn and integrate with on the client and can be challenging to support for some backends.

## Why synchronization?

While GraphQL has in some ways reduced the impedance mismatch of client/server development, rather than add a new language, I think we can solve most problems more efficiently by organizing our code according to the layered abstraction.  Consider that most client/server programming problems are synchronizing the overlapping aspects of shared data structures. Rather than just viewing this boundary as a protocol, it makes more sense to model it as the shared code and data, including the rules for validating, transfering, committing, and error handling. 

In essence, it's those slices of the code that make sense to be used on both sides on the protocol. Rather than a separate language like GraphQL, use layers to partition the server-only code and add metadata for properties and types to control how they are synchronized. For example, some properties might only transfer in one direction, or are loaded on demand. 

With synchronization, the framework generates statically typed classes by transforming the original source. Errors are caught at edit time, or runtime, and debugging is done on the transformed version that is a lot more natural than code generated from XML or inserted into the byte code.

Thinking about client/server programming as synchronization requires two important concepts that are fairly commonly used already:

* identify when an object has a unique id versus when it's part of the value of another object.
* for objects with an id, ensure the protocol respects the "highlander principle" - guaranteeing a single instance with the same id in each process. Sometimes these types of objects are called entities.

Code can access variables that point to entities declaratively and be assured of getting the right version of that instance. Any property changes will be validated and committed. Like with many powerful declarative abstractions, synchronization helps with offline, data update conflicts, retries, and more. 

## Sync concepts

For most business problems, synchronization is a better fit as the foundation. RPC is used for building special cases and specifically 'operational requests', typically used when there are only value objects and no objects with an id involved. 

To use synchronization, mark server types and properties as synchronized between client and server processes. Use metadata to override the defaults to limit sync to one-direction, to enable 'on-demand' fetching of a given property or instance, and more options. On the first request, the client receives the 'initial state' that includes the synchronized properties of objects referenced by the initial page.

To make changes, the application code updates properties, creates instances, etc as normal. Remote data can be fetched declaratively using data binding expressions. Annotations allow control over when and how objects are serialized and explicit APIs can be used as needed.

Changes are queued and sent to the server on the next 'sync'. The server applies those changes, and may return a batch of changes created in that operation, return with no changes, or wait if real-time is enabled. Sync maintains relationships between entities

When a new object is created on the server in response to a client's request, it can automatically sync to the client in the reply, or the data is lazily fetched the first time it's accessed.  In many applications, wrapper code goes away and the serialization protocol, validation logic, and more code can be shared cleanly by the client and server. 

When explicit RPC calls are needed, often they can be performed declaratively in data binding expressions and work in concert with synchronized objects.

## Organizing code in synchronization

Synchronization and layers allow code to be organized based on it's role in the client/server design. Code can be split into layers based on whether it runs on both the client and the server, or the server only, or client only. This is a nice way to break apart a design anyway to demarcate the code while sharing as much as possible. Since static typing is used, developers can navigate code and build code resilient to changes as code moves from one process to the next. The IDE provides edit time errors for referential integrity errors. 

## Automatic remote methods

Using layers to organize client server code offers benefits for RPC too.
When the client refers to a method that's only defined in the server, the system knows it's a remote method. Framework code can generate code to implement the call, or flag an error before the application is run.

## The synchronization library

Synchronization is implemented with a fairly small library usable as an API or hooks can be inserted into the transformed application code. Metadata and method hooks required for synchronization is inserted in the transformed version, preserving readability and debuggability.  

When a property is synchronized, it's automatically made bindable, converted into getX and setX methods where the setX fires a change event. Additionally, an addSyncInst call is inserted into the constructor or create method.

## Sync features

One of the advantages of declarative frameworks is the ability to enable/disable features with configuration. Details about the implementation is in the generated code, so it's still debuggable but does not affect the source itself.

### Eliminate async response handlers

With data binding and data sync together, the need for explicit asynchronous programming and function closures goes way down. Instead, expose methods that can be used in data binding expressions, or trigger method calls using binding change events. The code runs whether the method is in the same or a remote process. 

Forward bindings are useful for running queries on the server.

Reverse bindings are useful for invoking server remote methods.

Bi-directional bindings are a simple way to keep client and server state in sync.

When multiple changes fire at the same time, often due to chained bindings or methods run from a binding, the batch of changes is sent to the server and the stream of results are returned.  A set of properties are updated and the UI is updated in response to those changes.   

The same data binding expressions will work in either a client/server environment, or single-process which makes it easier to reuse domain model code, even when the domain model has remote methods. This is particularly valuable when a business user is editing data-binding expressions that control some combination of client and server functionality.

## Realtime, offline

Synchronization as a pattern also works in both directions and can tolerate temporary network disconnects. The client queues up changes for the server and vice versa. When using polling, the client picks up any queued changes waiting for it.  When using a realtime connection, the client can see the results immediately.

## Sync and scopes

Synchronization is built on the "scope" mechanism in StrataCode where different objects can be configured to have different lifecycles via an annotation.  An object can be global to the system, global for each application (for frameworks that support more than one per process like a web server), one per browser session, one per application per browser session, one per browser window, or one per request.  You can create your own scopes for a situation where you have a 'current something' - e.g. current tenant for a multi-tenant application, or current product for a product display component.

When scopes are nested, events propagate from the lower-level scope to the higher level one. The system performs necessary locking to prevent two conflicting threads from running at the same time using read/write locks. So if you have a shared object between two scopes, changes made by one are queued and delivered to the other on the next thread that runs in the destination scope.  

For example, the StrataCode command line can run methods on a selected application window on the browser.  This makes it easy to write test scripts for client/server applications, even those that support collaborative features.  

Test scripts can direct commands to the server or client or both. Test script logs are designed to record important, reproducible history for validation and diganostic purposes.  For example, the StrataCode html framework class TestPageLoader records the client javascript error log, the server log and the HTML output for the current page on both the client and the server.  

## Reliability and responsiveness

Using synchronization to manage state has a nice benefit for scaling web applications. There are a variety of scopes to cache data as needed for different purposes - global, session, or window.  When the server caches information, it avoids unnecessary database accesses and reduces response latency. Servers that need to scale frequently need to implement a separate caching layer but just like RPC it adds overhead to the development process and friction for when domain models change. With synchronization, caching options can be configured without code changes.

## Recovering state on failure

Synchronization is most efficient with a 'sticky session' environment, where clients requests return to the same server. This is also where caching is most effective since there's a continuous stream of requests from the same user, possibly accessing the same data. But when the server hosting a session fails, it's important to preserve the user's login state, and application context. Of course the session data could be replicated on another server, but the client is perhaps a more convenient way to preserve the synchronized state. When a client tries to sync and the server returns a 'session reset' response, it re-sends it's version of the initial state to the server. The server can restore the session and keep the user right where they left off.  The result is a seamless, high-end user experience with a low-cost from both coding and operation. 

## Balancing performance with coding effort

The sync library is designed to allow developers to support a balance of reliability and efficiency all from a declarative model.  I believe ultimately it will be an easy way to produce scalable web applications with low latency, simpler database architectures, and cheaper infrastructure cost. Most high-end web applications are probably already caching data with some "out of process" tool. Because these cache processes are not limited in heap size, and are shared between server processes, they might still be useful. With the proper framework integration, they could be enabled with configuration using the sync system. But for applications where the shared cache, or a massive cache is not required, the sync system can provide lower latency and more efficiency with less code and fewer servers.

## Falling back to stateless

When you really need a stateless environment, use 'request' scope at the page, or component level and the same models work but with more data transfered on each request. Data binding with RPC methods in a stateless environment is a nice alternative to existing stateless web frameworks.

## Easier multi-process development

There are many advantages to decoupling software components, as long as they can be efficiently managed independently.  We've all read about Microservices and the success of businesses like Amazon which made decoupling of systems a major priority.  But the downsides of a decoupled system are the design costs of choosing the pieces and the complexity of standing up a complete environment composed of many pieces.  Developers need a quick and reliable workflow where they can change code, build, run, and test even when they are touching code in more than one process.

With StrataCode, all processes in a solution can be built from the same stack of layers.  The layer definition files are also the perfect place for the code that manages the deployment process by updating and restarting processes as necessary.  So for any project, just running 'scc list-of-layers' should be the way any type of technical user can run a specific program. It should not matter how many processes or environments are required to implement that operation.  
Layers can handle all of the details - including all of the configuration specific to this user's environment. Because StrataCode itself is built on code-generation, supports maven, multiple processes, dependencies and more customizing it has the potential to be a more powerful tool for devops too. They can own production configuration layers which keep their environments separate from development, let them customize more aspects of the system, avoid copies, and use static typing for better code management of their assets.

See these examples of basic applications built using synchronization: <a href="/examples/unitConverter.html">UnitConverter</a>, <a href="/examples/todoList.html">TodoList</a>, and <a href="/examples/programEditor.html">Program Editor</a>.

<% ) %>
   </div>

   </div></div>
</body>

</html>

