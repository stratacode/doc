<html extends="ArticlePage">
<head title="Synchronization with Layers"/>

<body>
   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Synchronization with layers

by Jeff Vroom

One of the larger complicating factors in software design, performance, and maintenance begins when two programs need to communicate.  The developer needs to design or choose a protocol, perhaps adds versioning so it can be easily upraded or changed.  They need to make it secure, reliable and possibly deal with retries in case of failure or handle the additional connection related errors that might occur.  

In my experience, quite a bit of code goes into solving this problem.  It's one of the large contributors to "code that's not application logic" that developers spend time on - writing or debugging. 

## Client/server programming today

Today client/server programmers commonly use remote procedure calls (RPC) with a serialization protocol like JSON to communicate with the server.  It's common that frameworks require hand-written wrapper code to convert objects to and from JSON It's a manual process that adds friction to any change to the domain model.

More automated frameworks generate the serialization code using annotations on methods and their parameters or use a declarative file to define the protocol which generates code for both client and server.  This approach reduces the amount of code developers have to write and provides more features with the downside of adding problems during debugging. It's complex to manage all of the uses of 'rpc' that an application might need for a complex domain model that is evolving quickly with lots of read/write APIs required. Not super fun to debug generated code that comes from some XML file but it's better than nothing. 

GraphQL and other approaches have tried to create a declarative abstraction that's more powerful than basic RPC with some success, but it's quite common to see an explosion of RPC wrapper methods on top of domain models dealing with each new case your UI needs. Next time your domain model changes, it's more work updating all of that code you wrote to call the RPC and update the results.

## Why synchronization?

I think GraphQL is only a bandaid and that our tools could benefit from a different abstraction. Most client/server programming problems are really problems involving synchronizing data structures that live in different processes. There is really shared code and data and a complex, changing interaction involved with how and when different parts of this data structure are transfered, validated, updated, and ultimately committed to a database. 

Instead of using RPC as the base abstraction, what if the system modelled the synchronized aspects of the types used by both applications. Organize the overlapping parts of the code on each side using a shared layer of properties, validation rules, and business logic. The part that make sense on both sides.  Rather than a separate language like GraphQL, use metadata to define the default strategy for transfering each type in one or both directions, using on-demand versus eager strategies and some way to override the defaults when needed.

With this design, the framework can also help manage versions and compatibility, and generate statically typed classes by transforming the original source. Errors are caught at edit time, or runtime, and debugging is done on the transformed version that is a lot more natural than code generated from XML or inserted into the byte code.

Thinking about client/server programming as synchronization first requires two important concepts that are fairly commonly used already:
* identify when an object has a unique id versus when it's part of the value of another object.
* for objects with an id, ensure the protocol respects the "highlander principle' - guaranteeing a single instance with the same id in each process. Sometimes these types of objects are called entities.

Code can access variables that point to entities declaratively and be assured of getting the right version of that instance. Any property changes will be validated and committed. Like with many powerful declarative abstractions, synchronization helps with offline, data update conflicts, retries, and more. 

## Sync concepts

For most business problems, synchronization is a better fit as the foundation. RPC is used for building special cases and specifically 'operational requests', typically used when there are only value objects and no objects with an id involved. 

To use synchronization, mark server types and properties as synchronized between client and server processes. Use metadata to override the defaults to limit sync to one-direction, to enable 'on-demand' fetching of a given property or instance, and more options. On the first request, the client receives the 'initial state' that includes any instances created that are not marked with on-demand.  

To make changes, a client can simply update synchronized properties, create new instances, or use explicit API calls to fetch properties. Changes are queued and sent to the server on the next 'sync'. The server applies those changes, and may return a batch of changes created in that operation, return with no changes, or wait if real-time is enabled. Sync maintains relationships between entities

When a new object is created on the server in response to a client's request, it can automatically be sync'd to the client in the reply, or lazily fetched when it's first referenced by an object being sync'd to the client.  In many applications, wrapper code goes awayin favor of these annotations. 

When RPC is needed, it works naturally on top of the sync framework as synchronized objects can be passed by reference, not value. 

## Organizing code in synchronization

Synchronization and layers allow code to be organized based on it's role in the client/server design. Code can be split into layers based on whether it runs on both the client and the server, or the server only, or client only. This is a nice way to break apart a design anyway to demarcate the code while sharing as much as possible. Since static typing is used, developers can navigate code and build code resilient to changes as code moves from one process to the next. The IDE provides edit time errors for referential integrity errors. 

## Automatic remote methods

Using layers to organize client server code offers benefits for RPC too.
When the client refers to a method that's only defined in the server, the system knows it's a remote method. Framework code can generate code to implement the call, or flag an error before the application is run.

## The synchronization library

Synchronization is implemented with a fairly small library usable as an API or hooks can be inserted into the transformed application code. Metadata and method hooks required for synchronization is inserted in the transformed version, preserving readability and debuggability.  

Synchron is based on the same data binding change events. Just as with data binding, fields are converted to get/set methods and the set method has a call to send a change event. When a new synchronized instance is created, it calls an addSyncInst api that's inserted into the constructor or init code. 

## Sync features

One of the advantages of declarative frameworks is the ability to enable/disable complex features with simple configuration. Details about how implementation occurs is hidden. 

### Eliminate async response handlers

With data binding and data sync, there's no need for asynchronous programming or function closures. Expose a set of methods to declarative programmers in the same way that excel exposes functions. The declarative programmer can use them in data binding expressions without needing to know if the method runs on the client or the server. And the implementation can change later without changing the code that uses the method binding. 

Forward bindings are useful for running queries on the server.

Reverse bindings are useful for invoking server remote methods.

Bi-directional bindings are a simple way to keep client and server state in sync.

When multiple changes fire at the same time, often due to chained bindings or methods run from a binding, the batch of changes is sent to the server and the stream of results are returned.  A set of properties are updated and the UI is updated in response to those changes.   

The same data binding expressions will work in either a client/server environment, or single-process which makes it easier to reuse domain model code, even when the domain model has remote methods. This is particularly valuable when a business user is editing data-binding expressions that control some combination of client and server functionality.

## Realtime

Synchronization as a pattern also works in both directions.  The client can queue up changes for the server and vice versa.  When using polling, the client picks up any queued changes waiting for it.  When using a realtime connection, the client can see the results immediately.

## Sync and scopes

Synchronization is built on the "scope" mechanism in StrataCode where different objects can be configured to have different lifecycles via an annotation.  An object can be global to the system, global for each application (for frameworks that support more than one per process like a web server), one per browser session, one per application per browser session, one per browser window, or one per request.  You can create your own scopes for a situation where you have a 'current something' - e.g. current tenant for a multi-tenant application, or current product for a product display component.

When scopes are nested, events propagate from the lower-level scope to the higher level one. The system performs necessary locking to prevent two conflicting threads from running at the same time using read/write locks. So if you have a shared object between two scopes, changes made by one are queued and delivered to the other on the next thread that runs in the destination scope.  

For example, the StrataCode command line can run methods on a selected application window on the browser.  This makes it easy to write test scripts for client/server applications, even those that support collaborative features.  

Test scripts can direct commands to the server or client or both. Test script logs are designed to record important, reproducible history for validation and diganostic purposes.  For example, the StrataCode html framework class TestPageLoader records the client javascript error log, the server log and the HTML output for the current page on both the client and the server.  

## Reliability and responsiveness

Using synchronization to manage state has a nice benefit for scaling web applications. There are a variety of scopes to cache data as needed for different purposes - global, session, or window.  When the server caches information, it avoids unnecessary database accesses and reduces response latency. Servers that need to scale frequently need to implement a separate caching layer but just like RPC it adds overhead to the development process and friction for when domain models change. With synchronization, caching options can be configured without code changes.

## Recovering state on failure

Synchronization is most efficient with a 'sticky session' environment, where clients requests return to the same server. This is also where caching is most effective since there's a continuous stream of requests from the same user, possibly accessing the same data. But when the server hosting a session fails, it's important to preserve the user's login state, and application context. Of course the session data could be replicated on another server, but the client is perhaps a more convenient way to preserve the synchronized state. When a client tries to sync and the server returns a 'session reset' response, it re-sends it's version of the initial state to the server. The server can restore the session and keep the user right where they left off.  The result is a seamless, high-end user experience with a low-cost from both coding and operation. 

## Balancing performance coding effort

The sync library is designed to allow developers to support a balance of reliability and efficiency all from a declarative model.  I believe ultimately it will be an easy way to produce scalable web applications with low latency, simpler database architectures, and cheaper infrastructure cost. Most high-end web applications are probably already caching data with some "out of process" tool. Because these cache processes are not limited in heap size, and are shared between server processes, they might still be useful. With the proper framework integration, they could be enabled with configuration using the sync system. But for applications where the shared cache, or a massive cache is not required, the sync system can provide lower latency and more efficiency with less code and fewer servers.
l

## Falling back to stateless

When you really need a stateless environment, use 'request' scope at the page, or component level and the same models work but with more data transfered on each request. Data binding with RPC methods in a stateless environment is a nice alternative to existing stateless web frameworks.

## Easier multi-process development

There are many advantages to decoupling software components, as long as they can be efficiently managed independently.  We've all read about Microservices and the success of businesses like Amazon which made decoupling of systems a major priority.  But the downsides of a decoupled system are the design costs of choosing the pieces and the complexity of standing up a complete environment composed of many pieces.  Developers need a quick and reliable workflow where they can change code, build, run, and test even when they are touching code in more than one process.

With StrataCode, all processes in a solution can be built from the same stack of layers.  The layer definition files are also the perfect place for the code that manages the deployment process by updating and restarting processes as necessary.  So for any project, just running 'scc list-of-layers' should be the way any type of technical user can run a specific program. It should not matter how many processes or environments are required to implement that operation.  
Layers can handle all of the details - including all of the configuration specific to this user's environment. Because StrataCode itself is built on code-generation, supports maven, multiple processes, dependencies and more customizing it has the potential to be a more powerful tool for devops too. They can own production configuration layers which keep their environments separate from development, let them customize more aspects of the system, avoid copies, and use static typing for better code management of their assets.

See these examples of basic applications built using synchronization: <a href="/examples/unitConverter.html">UnitConverter</a>, <a href="/examples/todoList.html">TodoList</a>, and <a href="/examples/programEditor.html">Program Editor</a>.

<% ) %>
   </div>

   </div>
</body>

</html>

