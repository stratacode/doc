<html extends="ArticlePage">
<head title="Synchronization with Layers"/>

<body>
   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Client/Server Synchronization Using Layers

Today client/server programmers commonly use remote procedure calls (RPC) with a serialization protocol like JSON to communicate with the server.  Some languages require that you write code to convert to and from JSON, others handle that transparently, or declaratively.

The sync framework includes RPC directed by annotations, which cause a SyncManager.addSyncType(.) call to be made, registering the synchronized properties and their metadata. 

The biggest hassle with direct RPC code is that you have to handle the response asynchronously (at least when you are using an asynchronous runtime like the browser).  Stratacode gives you an option to avoid response listeners when you use remote methods in data binding expressions.  You can bind one or more read-write properties, to the results of a data binding expression, triggered by other client properties.  A stream of change events is sent to the server and the stream of results are returned.  A set of properties are updated and the UI is updated in response to those changes.   

When you use this model, you have declarative/functional access to data you retrieve asynchronously, and can cleanly invoke remote methods in response to events even when they are async.  The same data binding expressions will work in either a client/server environment, or local which makes it easier to reuse domain model code, even when the domain model has remote methods.  This is particularly valuable when a business user is editing data-binding expressions that control some combination of client and server functionality.

By it's nature, RPC involves copying state back and forth explicitly.  Programmers have to write that code explicitly and spend a lot of time with tricky code that amounts to reimplementing the same patterns over and over again.  What you are really doing here is synchronizing objects between the client and server.  StrataCode offers a model for doing just that - synchronize objects automatically.

You annotate classes, objects and properties with the [@Sync](/javadoc/sc/obj/Sync) annotation, or put them in a shared layer and annotate the layer itself with @Sync.  If you set @Sync on a the layer, StrataCode detects which layers overlap between different processes and generates code to synchronize the overlapping parts back and forth. 

When a type is marked with @Sync, calls are inserted into the code to track instance creation, and property changes.  Those events are recorded and sent to the client or server on the next sync (i.e. at the end of the request, or at the end of some user-interface interaction).

The synchronization framework lets you build rich, interactive apps, with complex graph-based data models with little to no remote procedure calls, no data transfer objects, and with a statically typed protocol - for efficient errors and easily versioned protocols.  The declarative patterns implemented by the sync framework support the most common uses cases - create, update, delete, lazily fetching of references and collections, and more.  When your application needs more control, you can set the @Sync annotation on properties or types to fine-tune the behavior.  If you still need more control, you can fall back to RPC on the same objects.

For ease of debugging and richness of features, the serialization format today is a StrataCode layer.  Before being sent to the browser, the layer is converted to JS so it loads and executes quickly.  It takes more time to generate the JS on the server however so it's not fast for large data sets.  We will build adapters to various serialization formats so you can choose JSON, or a more efficient binary protocol.

Read more in the [documentation](/syncFramework.html).

<% ) %>
   </div>

   </div>
</body>

</html>

