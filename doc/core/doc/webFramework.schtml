<html extends="DocPage">
<head title="StrataCode Web Framework"/>

<body>

   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Web framework overview

The web framework uses layers and code-generation to support the building of efficient components and applications. 

Some key features:

### Flexible runtime

The .schtml format supports dynamic HTML applications that might run on the server, in the browser, or both when used with the Java to Javascript converter.

<br><img src="../images/schtml3ways.jpg" style="border: solid 1px #0">

### Declarative, reactive, IDE support

Use code or data binding rules in the page to make templates reactive. As properties change in a reactive template, only the affected parts of the content are updated. The IDE suggests names even data binding expressions:

<br><img src="../images/schtmlReactive.png" style="border: solid 1px #0">

### Rapid development, efficient runtime

Dynamic templates are interpreted using the dynamic runtime. Refresh the template for most code changes, even when the template has state.

Switch to compiled mode for performance.

<br><img src="../images/schtmlTwoWays.png" style="border: solid 1px #0">

The .schtml file is converted to .sc, then to .java or .js. The generated code is fairly readable and useful for debugging.

### Inheritance for reuse

Tags use the 'extends' attribute to inherit from other tags. The new attributes and body content inherit or override those of the super tag unless the tagMerge attribute indiciates to replace, append or prepend instead.

### Layers for flexibility, customization

Templates can also be layered. When one schtml files modifies a downstream file, the attributes and body are combined just like extends.

Create customized versions of templates without copying. Manageable versioning using static typing, inheritance and the IDE, similar to Java. 

Organize application code according to dependencies and run code in multiple ways without refactoring. Keep UI code independent of the server and it can always run as a client-only version for rapid development, even when the server becomes large.

### Synchronization

Use real-time data for interactivity, or just better test scripts during development.

### Command line, testing

Use the command line interface for controlling and organizing multi-process applications. Target commands to specific processes, or send them to all processes. Build static typed test scripts and refactor them using the IDE.

## Getting started

To run the simpleSync example in clientServer mode:

    scc -v -vs example/simpleSync/clientServer

This builds and runs a "hello world" web application using the framework layers: js.schtml, jetty.schtml, and js.sync.  The -v option enables basic verbose logging and -vs enables verbose sync so you can see the client/server communication.

Use the same UI layer in server-only mode:

    scc -v -vs example/simpleSync/server

There are three application layers in this example: model, UI, and server. 

<% ) %>

<h3>Model layer</h3>

<%= sc.lang.SCLanguage.getSCLanguage().styleFile("example/simpleSync/model","HelloWorld.sc", false, false) %>

<h3>UI layer</h3>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/simpleSync/ui","HelloWorld.schtml", false, false) %>

<p>
In schtml files, an html attribute can use an expression with or without data binding by prefixing the attribute value with the "=" operator, or one of the <a href="dataBinding.html">data binding operators</a>: ":=", ":=:", or "=:".  
</p>
<p>
Use just the = operator for a simple one-time assignment. Use a forward data binding to update the attribute when the expression's value changes. Use a reverse binding to go in the reverse direction: either updating a property, calling a method etc.
</p>
<p>
The &lt;%= directive works like JSP to output an expression as content. When used in a declarative context, the expression uses a data binding expression so the content is updated incrementally. 
</p>

<h3>Server-only layer</h3>

<%= sc.lang.SCLanguage.getSCLanguage().styleFile("example/simpleSync/server","HelloWorld.sc", false, false) %>

<%= MarkDownPage.markDown(%>

For the server's version of the HelloWorld class, there's a forward binding which recomputes the value of 'reply' when the message property changes. The change to reply will be sync'd back to the client so the user sees that message printed in the JS console as well as the server's console. 

## How clientServer mode works

In clientServer mode, the UI and model layers run on both the client and the server. The initial HTML for the page is rendered on the server and displayed in the browser, then browser downloads the JS files, and then initialization code in the page runs. When that's complete, optionally the HTML is re-rendered on the client. It's usually the same so there's no flicker. 

When the user changes the input tag's value, the binding runs on the client to update the 'message' property. That change is sync'd to the server in a JSON request. When message property on the server changes, it updates the binding for the reply property. The reply property change is then sync'd back to the client in the response. This exchange happens all in one XHR request, logs in both client and server consoles show the exchange using the -vs option.

## How server-only mode works

In server only mode, no application code runs in the browser. One fixed, relatively small .js file is loaded to manage the back and forth communication with the server. The initial page response contains the server-rendered HTML and some embedded data that defines the list of 'server tags' - those which trigger events the server needs. 

For the simpleSync example, the input tag is a server tag. When it's value changes, the change is sent the server using an XHR request and applied to the server-side instance for that input tag for that window. That change triggers bindings which causes the innerHTML of the div tag to be returned in the response. 

## UnitConverter HTML UI 

Here is the .schtml template for the unitConverter examples UI:
<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/unitConverter/html/core","UnitConverter.schtml", false, false) %>

<%= MarkDownPage.markDown(%>

It uses the same model and coreui layers as the other frameworks it supports. It binds UI elements to properties like 'converters' and 'currentConverterIndex' defined in the those layers.

The first line applies the @URL annotation to set a shortcut URL (overridding the default which uses the template file name).

To run the clientServer version of the unit converter:

    scc -v -vs example/unitConverter/html/clientServer

To run the server only version:

    scc -v -vs example/unitConverter/html/server

The unitConverter sample also runs in the browser only, without a server:

    scc -v example/unitConverter/html/clientOnly

### Choosing the app's runtime

The layer js.schtml defines the javascript runtime and the jetty.schtml defines the java_Server process. By including one or both layers, the app uses one or both runtime/processes.

For a UI layer, unless it depends on server only or browser only features, it can extend the base layer html.schtml to permit either mode of operation.

Here's the base layer for unitConverter which supports any of the three modes of operation:
<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/unitConverter/html/core","core.sc", false, true) %>

<%= MarkDownPage.markDown(%>

Here's the layer to run for client/server mode:
<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/unitConverter/html/clientServer","clientServer.sc", false, true) %>

or run the server only layer:

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/unitConverter/html/server","server.sc", false, true) %>

or run the client-only layer:

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/unitConverter/html/clientOnly","clientOnly.sc", false, true) %>

<%= MarkDownPage.markDown(%>

Specify the layers as command line args to scc by passing layers like clientServer that only specify dependencies on other layers. For example, another way to run the clientServer version:

    scc example/unitConverter/html/core js/schtml jetty/schtml js/sync

## Top level pages versus components 

When a .schtml file starts with &lt;html&gt; it's treated as a top-level page and assigned a URL unless it's marked with abstract='true'. Other .schtml files generate a type in the system that can be used with extends inside of another template or used from code.

## URLs and mapping to template pages

At build time, the code generator collects a list of URLs defined by top-level pages in the system using the @URL annotation. For a given page, set @URL(pattern=".."). The pattern can be a fixed string value (as per the UnitConverter example), or contain page variable mappings using the PatternLanguage. 
Use the @QueryParam annotation on a top-level page variable for it to be mapped automatically onto query parameters in the URL.

See the [simpleBlog example](../examples/simpleBlog.html) for use of @QueryParam and @URL based parameters using patterns.

If the .schtml page does not include an @URL annotation, and the top level tag is 'html', the page object that's generated extends the default HtmlPage object in the html.schtml layer which sets @URL with no pattern. When no pattern is specified, the file name with the resultSuffix is used, e.g. PageName.html.  The layer's configuration sets or inherits the path prefix to prepend for files in it's directory. By default, files are accessed from their path relative to the layer's directory. So files in the layer directory itself are accessed with /fileName.html. 

## The TodoList example

The TodoList example is built in two layers, the model and UI. 

Here, the model layer contains the logic and for both the domain model and the view model in one:
<% ) %>

<%= sc.lang.SCLanguage.getSCLanguage().styleFile("example/todo/model","TodoList.sc", false, false) %>

Here is the UI layer which modifies the model layer:

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/todo/jsui","TodoList.schtml", false, false) %>

<%= MarkDownPage.markDown(%>

The template page can access fields defined in the model because both layers are merged into one type.

## Reactive versus procedural tags

When a tag only uses logic that can be converted to binding expressions, the generated code can incrementally refresh attributes and the body as properties change. Otherwise, the tag must be refreshed in code when its contents change. 

To make a tag reactive, use fields in the tag object, not local variables (i.e. use &lt;%! not &lt;% to define a variable value used in the tag body). If you need conditional logic, use the ? expression, not an if statement. Use the repeat attribute instead of a loop.

## Generating css using the .sccss format

Because css contains so many ways to set styles on an element, over time big projects can become hard to maintain unless managed carefully. Using simple classes as selectors as the main approach makes it easier to trace from the html element to the styles it uses. Css does not really have variables or expressions. It's common to use a wrapper language to add these features and then generate css at build time.

StrataCode does not yet have the ideal css wrapper language. We'd like to offer full 'find-usages and refactoring' support for styles, like you can do for Java and build in sensible variables, expressions, and other features using a compatible syntax to css itself.

As a first step, the current .sccss extension uses the same base template language that sits underneath .schtml files (and other formats like .scxml) but generates css instead of html. It supports the same &lt;% %&gt; operators as .schtml but only one class is generated with one large outputBody method.

These templates can either be evaluated at build/compile time, or when the .css file is requested, or in the JS runtime as properties change for "isomorphic dynamic css".

Here's an example:

<% ) %>

<code><pre>
      &lt;%!
         String borderColor = "#777";
         // With the SC template language, you can break back into a template expression for any string using &gt;%
         // The template language is really Java where strings are turned inside-out
         String dropShadow = %&gt;
            border-style: solid;
            border-width: 1px;
            border-color: &lt;%= borderColor %&gt;;
            box-shadow: 5px 5px 2px #aaaaaa;
         &lt;%;
      %&gt;

      #navMenu li ul {
         &lt;%= dropShadow %&gt;
      }

      #navMenu li ul ul {
         &lt;%= dropShadow %&gt;
      }

      .toggleButtonSelected {
         border-color: &lt;%= borderColorSelected %&gt;; 
      }
</pre></code>

<%= MarkDownPage.markDown( %>

## Relative URLs

Many web frameworks require absolute URLs in all references but relative URLs improve the reusability of components. For tag attributes that refer to URLs, like href and src, an absolute URL is rendered just as it was provided. But relative URLs will be rewritten using a function called getRelURL() that works even if the source template is included or extended from a template with a different top-level URL. It also reacts to changes made to the top-level page URL if your page needs to change it based on local navigation. 

TODO: We'd like to provide warnings in the IDE for URLs which cannot be resolved, offer navigation from the IDE for tag attributes and have a flag to display warnings for unresolveable URLs at build time. Detecting and avoiding broken links to internal pages is an important problem to get right.

## Images, static html etc.

For management of static files - resources for a desktop app, or web files in the web root, layers merge directory trees at build time, and later if you 'refresh' the page. More flexible than the typical doc root while still offering traceability, tooling, and reliability. Apps that do not conflict in the URLs they offer can be easily merged or separated. 

## Flexible path management

Layer definition files provide path management features to support flexible layer file organization that maps to flexible build directory organization. Different types of files, with different path prefixes can map to different locations in the build dir. 

Rather than a monolithic doc root, source assets are managed in containers appropriate for the project and developer at hand, setup by the framework developer. 

For multi-variant testing, workflow, review and staging the layered structure is a perfect fit because the directory structure only contains the deltas being made. 

## Details of tag objects

At code-generation time, the .schtml template page is converted into a Java class which is the root of a tag object tree. Important tags in the .schtml file are converted into inner classes of their enclosing tag object's class. A tag which is pure static content is usually converted to a String inside of it's enclosing tag's outputBody method for more efficient operation.

If an id attribute is specified, it is used as the class name. If not, a default name is chosen based on the tag name unless the tag is the top-level page in which case the file name is used.

Each tag object has a default base class chosen using the tag name. For example, the input tag class extends sc.lang.html.Input class by default. If the tag uses extends, the specified class is used instead.

## Configuring a tag component

When a sub tag extends a component tag, the sub tag may need to configure or override properties of the component. For the .schtml file, component tags define properties using the &lt;%! operator and those properties are settable in the sub tag as attributes.

See this in the PersonPage example:

<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("test/js/simplePerson","PersonPage.schtml", false, false) %>

<%= MarkDownPage.markDown(%>

The tag with id="PersonTemplate" defines an abstract tag class that has a 'data' property of type Person. When that tag is extended below, data is set to a Person instance.

Tags with abstract='true' are not rendered. 

It's possible to define tag macros in their own file. Just like with Java, the class name is based on the file name.

## Inheriting attributes and content

When one tag extends another it inherits or overrides the attributes of the super tag. By default, the body of the sub tag is merged with the inherited body but you can set tagMerge to append, prepend or replace the inherited content instead. The tagMerge attribute affects the default behavior for attributes as well. Use bodyMerge to specify a different mode for the body only. 

When using 'merge' mode for the body, any child tags of the sub tag are merged with child tags of the super tag if they have the same id. Tags with the same id inside of the body are themselves merged and so on. 

It's best to use explicit id attributes with sub-tags used in this merge operation. Sometimes, the default id causes a tag to be merged when unintended causing content to be lost. Either use tagMerge='append' or set an id on either the super tag or the sub tag so they are not merged.

Be careful not to extend a div tag from an input tag or another case where the tag implementation class does not match. 

## Setting attributes to expressions

When setting an attribute to a constant string, use standard HTML syntax: attributeName="constant value".

When setting an attribute to a variable just one time, use: attributeName="= variableName".

If the variable's value will change, to have the binding also change use a forward binding expression: attributeName=":= variableName".

## Client/server tag object API

The tag object API is supported on both the server and in the browser.

It exposes useful features of the JS "document object model", aka the DOM, to Java code. It provides bindable properties so templates can react to events such as click, mouse move, change, or resize. Other bindable properties let code bind to values like clientWidth, and clientWidth. Tags can be controlled with properties like style, visible, and more.

Here is a list of the main classes and links to the api doc:

* [Node](/javadoc/sc/lang/html/Node.html) - The common base class for both tags and attributes.
* [Element](/javadoc/sc/lang/html/Element.html), [HTMLElement](/javadoc/sc/lang/html/HtmlElement.html) - Used as the base classes for all tags in the page.
* [HtmlPage](/javadoc/sc/lang/html/HtmlPage.html), [Head](/javadoc/sc/lang/html/Page.html), [Body](/javadoc/sc/lang/html/Body.html), [Div](/javadoc/sc/lang/html/Div.html), [Input](/javadoc/sc/lang/html/Input.html), [A](/javadoc/sc/lang/html/A.html), [Form](/javadoc/sc/lang/html/Form.html), [Button](/javadoc/sc/lang/html/Button.html), [Option](/javadoc/sc/lang/html/Option.html), [Select](/javadoc/sc/lang/html/Select.html), [Form](/javadoc/sc/lang/html/Form.html), [Span](/javadoc/sc/lang/html/Span.html), [Style](/javadoc/sc/lang/html/Style.html).  

TODO: Should these have a 'Tag' suffix in the name?  I think DivTag, ATag would look a little better than just Div and A as class names.

It's possible to substitute a custom class for a tag name using the tagPackageList. This property of the LayeredSystem specifies a list of packages to search in order for the HtmlPage, Div, etc. classes. It's usually set by framework layers to point to a local package of templates or classes to use for each class. For example, the html.core layer calls:

      system.addTagPackageDirectory("sc.html.tag", this, 1);

to register the sc.html.tag package. The layer html.schtml extends html.core and defines a default HtmlPage.schtml template with a package name of sc.html.tag. So when that layer is included, StrataCode uses these classes as the default value for the 'extends' attribute for the &lt;html&gt; tag. 

This class serves as a good example for how framework features are implemented and how you can adjust behavior (see [HtmlPage](htmlPageDetails.html)). 

## Tag visibility

Set the 'visible' attribute to false to remove this tag from the parent's body.
When set back to true, the parent's body is re-rendered to include the tag again.
When the tag is invisible, it's useful to specify a substitute in some cases.  To support this, you can add a child tag with the special id="alt".  When the parent is invisible, the alt tag is put in it's place and vice versa. At runtime you sometimes need to refer to the tag's id in code. For the alt tag the id is: "&lt;parentId&gt;_alt" (e.g. foo_alt if the parent tag has id="foo"). 

<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("test/html/simpleVis","Vis.schtml", false, false) %>

<%= MarkDownPage.markDown(%>


Alternatively, control the tag visibility using the style attribute as in normal HTML, but using a binding to make the tag appear and disappear. With a boolean property called 'vis' use <code>style=':= vis ? "display:none" : ""'</code>

TODO: Currently when your tag is not visible, the bindings still run which means there is more overhead than necessary and care must be taken to avoid errors in the bindings in that state (like adding null tests). We should fix by activating/de-activating the bindings, or possibly creating/destroying the object.  A 'switch' option might be nice so you can have one instance which morphs into different implementations based on binding expressions.

## Detecting mouse over

The hovered property is set to true when your mouse is over an element. Bind to this property to adjust styles, trigger code etc for dynamic mouse over behavior.

## Dynamic styles

Set the style attribute using expressions or data binding for dynamic styles in the tag object. For example: 

    style=':= "background-color: " + (colorIsRed ? "red" : "blue")'

TODO: Should support a CSSStyleDeclaration property e.g. tag.style.width := panelWidth - 10;

## Changing the tag's css class

Like other bindable attributes, set class to the value of a binding expression.

    class=':= hovered ? "highlightClass" : ""'

## DOM Events

There are properties in the tag object for each of the DOM events that are available on any element. Use reverse-only bindings to call a method when an event is fired. A reverse-only binding can also perform an assignment. These expressions can refer to the value of the Event being fired to the timestamp, currentTarget, button pressed, etc. using properties in the event.

Here is the list of event properties that are supported:

clickEvent, dblClickEvent, mouseDownEvent mouseMoveEvent, mouseOverEvent, mouseOutEvent, mouseUpEvent, keyDownEvent, keyPressEvent, keyUPEvent, submitEvent, changeEvent, focusEvent, blurEvent, and a special combo event: mouseDownMoveUp for tracking click, drag, release.  

For example:

<% ) %>

<code>
    &lt;div id="clickMe" clickEvent='=: clicked = clicked + 1'&gt;
       <br>
       &nbsp;&nbsp; Clicked on &lt;%= clicked %&gt; times.
       <br>
    &lt;/div&gt;
</code>

<%= MarkDownPage.markDown(%>

## Client implementation of DOM events

Tag objects running in javascript, receive DOM events in an event handler that immediately refreshes any bindings. Bindings that require tags to be refreshed, invalidate those tags and schedule a 'do later handler' that is run after all pending events have been delivered.

So in the clickMe example above, only the body of the clickMe tag is re-evaluated when the button is clicked and that happens right away without calling the server.

## Server tag implementation of DOM events

A tagObject runs in 'server tag' mode when it's marked with exec='server', or the template page was compiled without the JS runtime. In either case, DOM events are sent from the client to the server. Bindings are processed there and the server tag object's content is invalidated. Once all events have been processed, any changed tags send their content back to the client where it's updated.

To implement this, when the initial page is rendered, metadata about the server tags is sent to the client along with the initial HTML. A small JS file called stags.js reads this data and adds the necessary event listeners so it can send over 'sync' messages to set the property.

In the server tag implementation of the clickMe example, the clickEvent is sent to the server as part of a 'sync' operation in response to the button being clicked. The server increments the clicked value, fires the binding which invalidates the body of the clickMe tag. After all events have been delivered, any changes tags are refreshed. The innerHTML property change event fires and the change is returned to the client where it's applied.

## Repeating Tags

Set the repeat attribute of a tag to a java.util.List or array (Object[]), and the tag is repeated, once for each element. By default, the element is available as 'repeatVar', but it's more convenient usually to use repeatVarName to provide the name of a new field created with a type matching the element type. So if you provide a List&lt;Book&gt; and set repeatVarName="book", the new field is created with the right type.

<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/simpleRepeat/ui","ShowBooks.schtml", false, false) %>

<%= MarkDownPage.markDown(%>

The 'wrap' property controls whether the repeat tag is itself repeated. With wrap='false', the tag with the repeat attribute is itself rendered once for each element. With wrap='true', only the body of the tag is repeated.

The default value for 'wrap' depends on the tag name. For dl, and ul (which both are typically list containers), wrap defaults to true. For all other tags wrap defaults to false. 

Use the class sc.util.ArrayList or send change events on the list value for the repeat tag to update as the list changes. For incremental changes made to the list, incremental changes are made to the corresponding DOM in common cases. See the EditBooks example:

<% ) %>

<%= sc.lang.HTMLLanguage.getHTMLLanguage().styleFile("example/simpleRepeat/ui","EditBooks.schtml", false, false) %>

<%= MarkDownPage.markDown(%>

## More control over the repeated tag

When different array elements need different tag objects for display, use the repeatWrapper attribute to specify an implementation of the [IRepeatWrapper](/javadoc/sc/lang/html/IRepeatWrapper.html) interface. In the createElement method, create and return a tag object for each element. 

TODO: should we just look at the 'extends' or 'implements' of the repeat tag and if it implements IRepeatWrapper, we can use the definition of the tag as the repeatWrapper and avoid one extra class.  We currently don't seem to use the inner tag class which gets generated in almost all of the places we use repeatWrapper. 

## Tag properties

All tag classes inherit from the same Element class, but special tag classes add additional features:

### Select tag 

* selectedIndex - reflects the selected index and usable in forward or reverse bindings.
* selectedValue - also usable in forward or reverse directions, as an alternative to selectedIndex.  Set this to point to a value in the array or List for optionDataSource.  It will select that item by default.  When the value changes, it points to the currently selected value.
* optionDataSource - set to the List to use for populating the option tags.

### Input tag 

* value - controls the value attribute in HTML
* disabled - controls the disabled attribute in HTML
* checked - controls the checked attribute for those input types which use it

### Img tag 

* src
* width
* height

### Option tag 

* selected
* disabled
* value 

## All tags: structural attributes

These attributes which apply to any tag affect the code generation process: 

* extends - refers to the type name of a tag object to use as the base class for this tag.  By default, the attributes and body are both inherited but this can be controlled via the tagMerge and bodyMerge attributes.
* implements - specifies a list of tags objects from which to inherit attributes and content.  Also controlled by tagMerge and bodyMerge.
* abstract - when true, the tag object is not instantiated in the parent page.  It's a way to essentially define a tag class macro which you can extend in other instances or create using an API.
* repeat - refers to a List or array of items.  The tag is replicated once for each item.  Use repeatVarName to specify the name of the variable to store the array element.
* repeatVarName - used with repeat to define a variable name other than "repeatVar" to hold the value.
* repeatWrapper - used with repeat to specify the extends class for the repeat wrapper class
* serverContent - set this to true on a tag object you do not want rendered in the client. It's similar but slightly different than exec="server". When you set exec="server", when building the client version this object is omitted entirely so it won't be present when rendering the initial .html file. We also use serverContent in stubs inserted into the client tag objects to represent chunks of content where we should preserve the existing innerHTML of the DOM object when the parent is being re-rendered.
* exec - set to either 'client', 'server' or 'default'.  use this when you have a file that's shared by both client and server but where you only want the tag to be included in either the client or server's version of the page object. Use 'default' to handle the case where you want it in the client for client-only applications and the server for client-server applications.
* tagMerge - specifies how the tag and it's attributes are merged with any modified tag object, the extends and implements tag objects. A value of 'merge' is the default. Set it to 'replace' for this tag to entirely replace the previous one. Set it to append, or prepend. Affects both the body and attributes unless bodyMerge is set. See the [javadoc for MergeMode](/javadoc/sc/lang/html/MergeMode.html) for more info.
* bodyMerge - specifies just how the body of the tag is merged, for when you want to merge the body of the tag differently from the attributes. Same values as tagMerge.
* addBefore, addAfter - set to the id of an inherited tag used to place this tag either before or after.

## Document, Location, Window

These classes emulate parts of the corresponding JS apis.

Set window.location.pathname to change the browser's URL from either the server or the client.

Listen to changes to window.innerWidth/innerHeight to receive notifications of the window resize. 

Use document to listen for global mouse events.

javadoc: [Document](/javadoc/sc/lang/html/Document.html), 
[Location](/javadoc/sc/lang/html/Location.html), 
[Window](/javadoc/sc/lang/html/Window.html).

## Imports 

Just like JSP, you can add imports for the page and annotations on the top-level class object using the &lt;%@ annotation as the first thing in the file.  

<% ) %>

<code>
    <%= templateSnippets.annotationsOp %>
         import myClass;
    <%= templateSnippets.closeOp %>
</code>

<%= MarkDownPage.markDown(%>

## Annotations

To annotate the class corresponding to the page itself, you use:

<% ) %>
<code>
    <%= templateSnippets.annotationsOp %>
        @AnnotationName(annotationValues=...)
    <%= templateSnippets.closeOp %>
</code>

<%= MarkDownPage.markDown(%>

## Live in-browser programming

StrataCode as a framework supports changing the code while the application is running.  Just as these changes can sometimes be applied to the server code at runtime without a restart, they can be converted to Javascript code and run on the client.  When the changes are more complex, the complete javascript on the server is regenerated and the client page is told to refresh.  If the server tag types are dynamic, they too can be easily updated and refreshed.   If you use compiled tag types, the server may need to restart because of changes to compiled code. 

### Implementation details

Read about the implementation of [java to javascript](jsFramework.html) and [tag objects](tagObjects.html). 

<% ) %>

     </div>
   </div>
</body>
</html>
