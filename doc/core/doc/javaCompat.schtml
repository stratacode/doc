<html extends="DocPage">
<head title="Java Compatibility"/>

<body>

   <div id="content"><div id="mainSection">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

This section describes both the basics around importing existing Java code, and at a language level, the compatibility between StrataCode code and Java code.

## Importing compiled Java libraries

StrataCode is designed to make it easy to work with Java code bases. In the layer definition file, add jar files to the classpath of the system.  Classes that are added to the classpath can only be modified with annotation layers. 

Annotation layers can change the code generated for using these classes - for example, any class that extends a compiled class can be treated as though it had the @Component annotation, or mark a property with @Bindable so that a sub-class will have a bindable getX/setX for that property even if the base-class property was not. Mark properties as constant to avoid warnings from the data binding system. Add code-templates to a class for defining instances using the object keyword.

But compiled types cannot be modified to add or override new fields, or methods or other operations that require the source of the class.
Compiled classes in StrataCode are treated as JavaBeans using the get/set pattern so their properties are accessible as ordinary properties, without calling the getX/setX method. 

## Package manager hooks

To automate installs and updates, StrataCode has a repository package management system. There are RepositoryManagers for git, http, and maven. During the runtime, these package managers can ensure all dependencies are met before loading the Java code and do any installation or updates necessary.

## Compilation of Java and StrataCode 

To use more StrataCode language features, let it process source files. Either put source files directly into layers or add them to the srcPath of the layer.

Each layer contains a mix of Java, StrataCode files, or other file types exposed to that layer. The .scj suffix is recognized as well as .java for these files so that the StrataCode plugin processes those files instead of the built-in support. StrataCode translates all files to Java files before compiling. If a layer has Java files that don't need processing, these files are passed through unchanged. 

The only changes made to .java or .scj files are cosmetic: add missing package tags, inherit a layer's default modifier, or add layer imports. 

## Compatibility with Java

Most .java files work the same with the .sc extension. It usually compiles unless there is an odd name conflict in the generated code. The biggest change is that fields and references in StrataCode may be automatically converted to getX and setX methods using the JavaBean naming convention. So when renaming a .java file to .sc, the generated .java file may be different than the original or not if it does not hit any of these features. 

For .sc files when a field is used in a data binding expression, marked with @GetSet or used as a DB property, it's automatically converted to getX/setX methods and references to that field are converted to getX or setX calls. Such changes made to a source file affect only those lines because of the parselets framework. 

Another difference between StrataCode and Java is that in a Java interface, a non-static field is treated the same as if you added the static keyword.  But in StrataCode an interface's non-static fields are treated as "instance fields", and automatically added to all implementing classes during code-preprocessing.  It also adds getX and setX methods for that property to the interface and changes the code which references that field to a getX/setX call.  It's a simple form of multiple inheritance but works great, especially with default methods.

If you do not want this behavior for a given interface, do not rename it to have the .sc suffix or add static/final modifiers. 

There are a few other minor compatibility problems where Java code might not compile as StrataCode.  With the object operator classes and instances are defined in the same name space.  But Java allows types and variables to have the same names - the context always determines whether the language expects a type or a variable and can determine which to use based on the context. To remove the ambiguity that results, StrataCode will treat types and variables of the same name as an error unless the variable is of that type.  So in StrataCode, if you have two classes named "foo" and "bar", this code compiles: "foo foo; bar bar;" but this code gives errors: "bar foo; foo bar;"

<% ) %>

     </div>
   </div></div>
</body>
</html>
