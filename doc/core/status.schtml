<html extends="MainPage">
<head title="Status of StrataCode features"/>

<body>

   <div id="content" section="status">
       <div id="mainContent" exec="server">
          <div id="mainContentBody">

<%= MarkDownPage.markDown( %>
## Status of StrataCode features

Status of various StrataCode components based on current testing: 

* Note: some names and interfaces may change based on feedback

## code-processor
* beta: parselets, java support, sc, sct, schtml formats
* alpha: process-constraints, maven emulation, modelCache (may need to clear modelCache directory from time to time)
* pre-alpha: incremental compilation (beyond using it to run an app with no file changes)

## dynamic runtime
Beta quality for basic Java features. Not much testing of lambdas. Refresh of changes is pre-alpha but works for property changes, add field, add/remove class, and method changes.

## frameworks
* beta: data binding, components, properties, sync (although it's missing large collection support), java-to-js web framework (although missing some apis you might need, they are easy to add) 
* alpha/pre-alpha: cross-scope bindings for collaboration, web security, request scope, server tags, merging layers of schtml

## management ui:
* alpha support for existing features
* missing 'find' page, delete, more refinement overall and more customizability

## intellij plugin:
* beta except for: find-usages/refactoring (feature missing inheritance, field to getX/setX mapping). Editing of layer definition files (sometimes requires an IDE restart or flush caches), debugger sometimes breaks in generated code and messes up for some block transitions, and anonymous class breakpoints only work when setting in the generated code, editing scr files 

## Java to Javascript

The Java to Javascript converter is beta quality for Java 6 features. Because most Java code depends on runtime libraries that may not be available, it's not a seamless way to run any Java code in the browser. The test suite contains over 200K lines of Java that's converted without workarounds, JDK classes added as needed. Currently it uses the Apache java utilities which support only Java 1.6. Java 1.8 Lambdas have been implemented in the code-gen by converting to inner classes, but that conversion has not been tested due to the missing libraries.

The converter uses a relatively high level of emulation of native Java classes to keep download size manageable. It's easy to replace any class with a native version using an annotation. Right now, the code is still readable and no optimizations to remove unused code so lots of future optimization potential even though performance is not bad. 

All number types in Java (int, float, Integer, etc) are converted to Javascript's single number type. A cast to an int type will insert a call to Math.floor, some features of BigDecimal are supported and it's possible to wrap those integers that really need to be integers but that works is not complete.

Currently, the entire JS app is downloaded after the page is rendered but the layered organization would be a perfect way to separate subsets of layers to be progressively loaded. Just mark layers in your stack as 'download layers' and the rest could be automated. For large client applications, you'll be able to start interacting with the app with the base layers, while successive layers are downloaded. The static type system would help manage the dependencies to be sure each individual stack defined a valid application and framework hooks installed to help provide a smooth transition from one to the next.

## DB framework

Pre-alpha. Unit tests are running for the import features against a single Postgresql database and in-memory mode (no database).

## Android

There's a prototype of an android framework that supported the unit converter and simple applications but has not been tested in a while.

## Futures

These are a few future ideas we have for ways to leverage StrataCode and layers:

* Management UI customization for editing HTML UIs - navigate from UI to form view and code view, new tag, new attribute, resize for fixed position elements, etc. Direct manipulation of UI controls - e.g. setting styles, alignment rules, etc. right from the widget.

* Layered persistence framework - add additional data sources and in-memory joins: efficient blob storage and secret store are the two that are needed for a complete implementation. Still need to finish the 'staging mode' implementation, where we generate a 'staging schema' that can be used to store changes made as part of a workflow. Those will be seamlessly merged into queries and other apis for testing purposes. This schema won't have the integrity constraints since it will be just a layer on top of the main database. More management UI integration, particularly with schema manager. Or maybe new properties are just marked as dyn columns so they go into the dynamic part of the tables?  Need to add 'find panel' to the management UI based on the DB findBy features.

* Management of clusters of systems and router configuration. Today there's a cluster of tools that manage the entire lifecycle of application configuration, management, and deployment. Each step of the way has it's own way to organize, configure, and manage systems and lots of effort goes into integrating different aspects from code-changes, building, testing, and deploying, then adding necessary management UIs for the running system, and managing updates. StrataCode has the combination of features to manage overall organization and provide the tools for the complete process. Because it's based on code-generation, it can generate configuration files using system-wide awareness of the configuration. It can partition the system into multiple processes, with overlapping requirements and components. Layers allow seamless separation of deployment configuration to keep it secure. The declarative programming model that cuts across it all with built-in management UIs will make for a fast, manageable, configurable way to build multi-process systems. The routing logic and load balancing can be generated as well.

* If the concepts here catch on, would it make sense to provide a marketplace for businesses to have access to more configurable, customizable, reliable, secure software on inexpensive monthly source code subscriptions, rolled up amongst all the layers they use. Separate software from the cloud but find a way to pay for maintenance. Perhaps a public benefit organization for trusted developers who are fairly compensated from the subscription revenue they earn by building code, and supporting layers they contribute to.

<% ) %>
        </div>
     </div>
   </div>
</body>
</html>
